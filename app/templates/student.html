<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Focus Tracker - Student Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      min-height: 100vh;
      color: #e5e7eb;
      padding: 20px;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 24px 32px;
      border-radius: 16px;
      margin-bottom: 24px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 10px 40px rgba(102, 126, 234, 0.3);
    }
    
    .header h1 { font-size: 28px; font-weight: 700; }
    .header .subtitle { opacity: 0.9; font-size: 14px; margin-top: 4px; }
    
    .join-section {
      background: #1e293b;
      border-radius: 16px;
      padding: 40px;
      max-width: 500px;
      margin: 100px auto;
      text-align: center;
      border: 1px solid #334155;
    }
    
    .join-section h2 { margin-bottom: 24px; font-size: 24px; }
    
    .join-section input {
      width: 100%;
      padding: 14px 18px;
      border: 2px solid #334155;
      border-radius: 10px;
      font-size: 16px;
      margin-bottom: 16px;
      background: #0f172a;
      color: #e5e7eb;
      transition: border-color 0.2s;
    }
    
    .join-section input:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .join-section button {
      width: 100%;
      padding: 14px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    
    .join-section button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
    }
    
    .dashboard { display: none; }
    .dashboard.active { display: block; }
    
    .main-grid {
      display: grid;
      grid-template-columns: 1fr 400px;
      gap: 24px;
    }
    
    @media (max-width: 1200px) {
      .main-grid { grid-template-columns: 1fr; }
    }
    
    .card {
      background: #1e293b;
      border-radius: 16px;
      padding: 24px;
      border: 1px solid #334155;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }
    
    .card-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .video-container {
      position: relative;
      width: 100%;
      aspect-ratio: 4/3;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 20px;
    }
    
    video, canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
    }
    
    canvas { pointer-events: none; }
    
    .status-badge {
      position: absolute;
      top: 12px;
      right: 12px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px 14px;
      border-radius: 20px;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      backdrop-filter: blur(10px);
    }
    
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #22c55e;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 16px;
    }
    
    .metric-card {
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      border: 1px solid #334155;
    }
    
    .metric-label {
      font-size: 11px;
      color: #94a3b8;
      text-transform: uppercase;
      font-weight: 600;
      margin-bottom: 8px;
      letter-spacing: 0.5px;
    }
    
    .metric-value {
      font-size: 28px;
      font-weight: 700;
      color: #e5e7eb;
    }
    
    .metric-value.high { color: #22c55e; }
    .metric-value.medium { color: #eab308; }
    .metric-value.low { color: #ef4444; }
    
    .emotion-display { font-size: 42px; margin-top: 4px; }
    .emotion-name { font-size: 12px; color: #94a3b8; margin-top: 4px; text-transform: capitalize; }
    
    .focus-timer {
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      border-radius: 12px;
      padding: 24px;
      text-align: center;
      margin-bottom: 20px;
      border: 1px solid #334155;
    }
    
    .timer-display {
      font-size: 48px;
      font-weight: 700;
      font-family: 'SF Mono', monospace;
      color: #667eea;
      margin: 16px 0;
    }
    
    .timer-label { font-size: 12px; color: #94a3b8; text-transform: uppercase; }
    
    .timer-controls {
      display: flex;
      gap: 12px;
      justify-content: center;
      margin-top: 16px;
    }
    
    .timer-btn {
      padding: 10px 20px;
      border-radius: 8px;
      border: none;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .timer-btn.primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    
    .timer-btn.secondary {
      background: #334155;
      color: #e5e7eb;
    }
    
    .timer-btn:hover { transform: translateY(-2px); }
    
    .break-reminder {
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      color: #1a1a2e;
      padding: 16px 20px;
      border-radius: 12px;
      margin-bottom: 20px;
      display: none;
      align-items: center;
      gap: 12px;
      animation: slideIn 0.3s ease;
    }
    
    .break-reminder.active { display: flex; }
    
    @keyframes slideIn {
      from { transform: translateY(-10px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    .break-reminder-icon { font-size: 24px; }
    .break-reminder-text { flex: 1; font-weight: 500; }
    
    .break-reminder button {
      background: rgba(0, 0, 0, 0.2);
      border: none;
      color: #1a1a2e;
      padding: 8px 16px;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
    }
    
    .mood-chart-container {
      height: 200px;
      margin-top: 16px;
    }
    
    .mood-history {
      max-height: 300px;
      overflow-y: auto;
    }
    
    .mood-entry {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: #0f172a;
      border-radius: 8px;
      margin-bottom: 8px;
      border: 1px solid #334155;
    }
    
    .mood-emoji { font-size: 24px; }
    .mood-details { flex: 1; }
    .mood-time { font-size: 11px; color: #64748b; }
    .mood-attention { font-size: 14px; font-weight: 600; }
    
    .trend-indicator {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
    }
    
    .trend-indicator.improving { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
    .trend-indicator.stable { background: rgba(234, 179, 8, 0.2); color: #eab308; }
    .trend-indicator.declining { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
    
    .session-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin-top: 16px;
    }
    
    .session-stat {
      background: #0f172a;
      padding: 16px;
      border-radius: 10px;
      text-align: center;
      border: 1px solid #334155;
    }
    
    .session-stat-value { font-size: 24px; font-weight: 700; color: #667eea; }
    .session-stat-label { font-size: 11px; color: #94a3b8; margin-top: 4px; }
    
    .connection-status {
      text-align: center;
      padding: 10px 16px;
      border-radius: 8px;
      font-size: 13px;
      margin-bottom: 16px;
      background: #334155;
      color: #94a3b8;
    }
    
    .connection-status.connected { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
    .connection-status.error { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
    
    .debug-info {
      font-family: 'SF Mono', monospace;
      font-size: 11px;
      color: #64748b;
      padding: 12px;
      background: #0f172a;
      border-radius: 8px;
      margin-top: 16px;
    }
    
    .insights-card {
      background: linear-gradient(135deg, #667eea20 0%, #764ba220 100%);
      border: 1px solid #667eea40;
    }
    
    .insight-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 0;
      border-bottom: 1px solid #334155;
    }
    
    .insight-item:last-child { border-bottom: none; }
    .insight-icon { font-size: 20px; }
    .insight-text { font-size: 14px; color: #cbd5e1; }
  </style>
</head>
<body>
  <div class="container">
    <div class="join-section" id="joinSection">
      <h2>Join Focus Session</h2>
      <p style="color: #94a3b8; margin-bottom: 24px;">Enter your student ID to start tracking your focus and mood</p>
      <input type="text" id="studentIdInput" placeholder="Enter your Student ID" required>
      <input type="text" id="studentNameInput" placeholder="Enter your Name (optional)">
      <button onclick="joinSession()">Start Focus Session</button>
    </div>
    
    <div class="dashboard" id="dashboard">
      <div class="header">
        <div>
          <h1>Focus Tracker</h1>
          <p class="subtitle">Real-time attention monitoring with mood insights</p>
        </div>
        <div style="text-align: right;">
          <div style="font-size: 14px; opacity: 0.9;">Student: <span id="studentNameDisplay">--</span></div>
          <div style="font-size: 12px; opacity: 0.7;">ID: <span id="studentIdDisplay">--</span></div>
        </div>
      </div>
      
      <div class="break-reminder" id="breakReminder">
        <span class="break-reminder-icon">&#9749;</span>
        <span class="break-reminder-text" id="breakReminderText">Time for a break! You've been focusing for 25+ minutes.</span>
        <button onclick="takeBreak()">Take Break</button>
        <button onclick="dismissBreak()">Dismiss</button>
      </div>
      
      <div class="main-grid">
        <div class="left-column">
          <div class="card">
            <div class="card-title">Live Camera Feed</div>
            <div class="connection-status" id="connectionStatus">Initializing...</div>
            
            <div class="video-container">
              <video id="webcam" autoplay muted playsinline></video>
              <canvas id="canvas"></canvas>
              <div class="status-badge">
                <div class="status-dot"></div>
                <span>Monitoring</span>
              </div>
            </div>
            
            <div class="metrics-grid">
              <div class="metric-card">
                <div class="metric-label">Attention Score</div>
                <div class="metric-value" id="attentionScore">--</div>
              </div>
              <div class="metric-card">
                <div class="metric-label">Engagement</div>
                <div class="metric-value" id="engagementLevel">--</div>
              </div>
              <div class="metric-card">
                <div class="metric-label">Current Mood</div>
                <div class="emotion-display" id="emotionDisplay">--</div>
                <div class="emotion-name" id="emotionName">detecting...</div>
              </div>
            </div>
            
            <div class="debug-info" id="debugInfo">Initializing face detection...</div>
          </div>
          
          <div class="card" style="margin-top: 24px;">
            <div class="card-title">Attention Trend</div>
            <div class="mood-chart-container">
              <canvas id="attentionChart"></canvas>
            </div>
          </div>
        </div>
        
        <div class="right-column">
          <div class="card">
            <div class="card-title">Focus Timer</div>
            <div class="focus-timer">
              <div class="timer-label">Session Duration</div>
              <div class="timer-display" id="timerDisplay">00:00:00</div>
              <div class="timer-controls">
                <button class="timer-btn secondary" id="pauseBtn" onclick="togglePause()">Pause</button>
                <button class="timer-btn primary" onclick="endSession()">End Session</button>
              </div>
            </div>
            
            <div class="session-stats">
              <div class="session-stat">
                <div class="session-stat-value" id="avgAttention">--</div>
                <div class="session-stat-label">Avg Attention</div>
              </div>
              <div class="session-stat">
                <div class="session-stat-value" id="breaksTaken">0</div>
                <div class="session-stat-label">Breaks Taken</div>
              </div>
            </div>
          </div>
          
          <div class="card insights-card" style="margin-top: 24px;">
            <div class="card-title">Focus Insights</div>
            <div id="insightsContainer">
              <div class="insight-item">
                <span class="insight-icon">&#128200;</span>
                <span class="insight-text">Start focusing to see your insights</span>
              </div>
            </div>
          </div>
          
          <div class="card" style="margin-top: 24px;">
            <div class="card-title">
              Mood History
              <span class="trend-indicator stable" id="trendIndicator">Stable</span>
            </div>
            <div class="mood-history" id="moodHistory">
              <div class="mood-entry">
                <span class="mood-emoji">--</span>
                <div class="mood-details">
                  <div class="mood-attention">Waiting for data...</div>
                  <div class="mood-time">--</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    const SERVER_URL = window.location.origin;
    const POLL_INTERVAL = 30 * 1000;
    const EMOTION_DETECT_INTERVAL = 500;
    
    const LEFT_EYE_IDX = [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398];
    const RIGHT_EYE_IDX = [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246];
    const LEFT_EYEBROW_IDX = [336, 296, 334, 293, 300, 276, 283, 282, 295, 285];
    const RIGHT_EYEBROW_IDX = [107, 66, 105, 63, 70, 46, 53, 52, 65, 55];
    const MOUTH_OUTER_IDX = [61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 291, 409, 270, 269, 267, 0, 37, 39, 40, 185];
    const MOUTH_INNER_IDX = [78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 308, 415, 310, 311, 312, 13, 82, 81, 80, 191];
    const RIGHT_IRIS_CENTER = 468;
    const LEFT_IRIS_CENTER = 473;
    
    let studentId, studentName, studentGuid;
    let faceMesh, camera;
    let emotionHistory = [];
    let previousAttentionScore = 0;
    let faceApiReady = false;
    let currentEmotion = 'neutral';
    let lastEmotionDetectTime = 0;
    let isSessionActive = false;
    let eyesClosedCount = 0;
    let isPaused = false;
    let sessionStartTime = null;
    let pausedTime = 0;
    let breaksTaken = 0;
    let attentionChart = null;
    let attentionData = [];
    let moodHistoryData = [];
    
    let batchAccumulator = {
      count: 0,
      attentionSum: 0,
      facePresentCount: 0,
      gazeOnScreenCount: 0,
      eyesClosedCount: 0,
      emotions: {}
    };
    
    const emotionEmojis = {
      'happy': '&#128522;', 'surprised': '&#128558;', 'angry': '&#128544;', 'sad': '&#128546;',
      'fearful': '&#128552;', 'disgusted': '&#129314;', 'neutral': '&#128528;'
    };
    
    function drawLandmarkPoints(ctx, landmarks, indices, color, size = 2) {
      ctx.fillStyle = color;
      indices.forEach(idx => {
        const point = landmarks[idx];
        if (point) {
          ctx.beginPath();
          ctx.arc(point.x * ctx.canvas.width, point.y * ctx.canvas.height, size, 0, 2 * Math.PI);
          ctx.fill();
        }
      });
    }
    
    function drawLandmarkLine(ctx, landmarks, indices, color, lineWidth = 2, closed = true) {
      if (indices.length < 2) return;
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.beginPath();
      const first = landmarks[indices[0]];
      if (!first) return;
      ctx.moveTo(first.x * ctx.canvas.width, first.y * ctx.canvas.height);
      for (let i = 1; i < indices.length; i++) {
        const point = landmarks[indices[i]];
        if (point) ctx.lineTo(point.x * ctx.canvas.width, point.y * ctx.canvas.height);
      }
      if (closed) ctx.closePath();
      ctx.stroke();
    }
    
    function drawPoint(ctx, landmark, color, size = 4) {
      if (!landmark) return;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(landmark.x * ctx.canvas.width, landmark.y * ctx.canvas.height, size, 0, 2 * Math.PI);
      ctx.fill();
    }
    
    function euclideanDist(a, b, width, height) {
      const dx = (a.x - b.x) * width;
      const dy = (a.y - b.y) * height;
      return Math.hypot(dx, dy);
    }
    
    function eyeAspectRatio(landmarks, indices, width, height) {
      const [p1, p2, p3, p4, p5, p6] = indices.map(i => landmarks[i]);
      const v1 = euclideanDist(p2, p6, width, height);
      const v2 = euclideanDist(p3, p5, width, height);
      const h = euclideanDist(p1, p4, width, height);
      return h <= 1e-6 ? 0 : (v1 + v2) / (2.0 * h);
    }
    
    function estimateGazeDirection(landmarks) {
      const rightEyeInner = landmarks[133];
      const rightEyeOuter = landmarks[33];
      const leftEyeInner = landmarks[362];
      const leftEyeOuter = landmarks[263];
      const rightIris = landmarks[RIGHT_IRIS_CENTER];
      const leftIris = landmarks[LEFT_IRIS_CENTER];
      
      if (!rightEyeInner || !rightEyeOuter || !leftEyeInner || !leftEyeOuter || !rightIris || !leftIris) {
        return { lookingCenter: true, gazeOffsetX: 0, gazeOffsetY: 0 };
      }
      
      const rightEyeWidth = rightEyeOuter.x - rightEyeInner.x;
      const rightIrisRatio = (rightIris.x - rightEyeInner.x) / (rightEyeWidth + 0.001);
      const leftEyeWidth = leftEyeInner.x - leftEyeOuter.x;
      const leftIrisRatio = (leftIris.x - leftEyeOuter.x) / (leftEyeWidth + 0.001);
      const avgIrisRatio = (rightIrisRatio + leftIrisRatio) / 2;
      const lookingCenter = avgIrisRatio > 0.35 && avgIrisRatio < 0.65;
      
      return { lookingCenter, gazeOffsetX: avgIrisRatio - 0.5, gazeOffsetY: 0 };
    }
    
    function estimateHeadInFocus(landmarks) {
      const leftEye = landmarks[33];
      const rightEye = landmarks[263];
      const nose = landmarks[1];
      
      if (!leftEye || !rightEye || !nose) return { inFocus: true, horizontalOffset: 0 };
      
      const midEyeX = (leftEye.x + rightEye.x) / 2.0;
      const offsetX = Math.abs(nose.x - midEyeX);
      const isFacingStraight = offsetX < 0.06;
      
      return { inFocus: isFacingStraight, horizontalOffset: offsetX };
    }
    
    async function loadFaceApiModels() {
      try {
        const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model';
        await Promise.all([
          faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
          faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL)
        ]);
        faceApiReady = true;
        console.log('Face-api.js models loaded');
        return true;
      } catch (error) {
        console.error('Failed to load face-api models:', error);
        return false;
      }
    }
    
    async function detectEmotionWithFaceApi(video) {
      if (!faceApiReady || !video) return null;
      try {
        const detection = await faceapi
          .detectSingleFace(video, new faceapi.TinyFaceDetectorOptions({ inputSize: 224, scoreThreshold: 0.5 }))
          .withFaceExpressions();
        
        if (detection && detection.expressions) {
          let maxEmotion = 'neutral';
          let maxProb = 0;
          for (const [emotion, probability] of Object.entries(detection.expressions)) {
            if (probability > maxProb) {
              maxProb = probability;
              maxEmotion = emotion;
            }
          }
          return maxEmotion;
        }
      } catch (error) {
        console.error('Emotion detection error:', error);
      }
      return null;
    }
    
    function getSmoothedEmotion(currentEmotion) {
      emotionHistory.push(currentEmotion);
      if (emotionHistory.length > 5) emotionHistory.shift();
      
      const counts = {};
      emotionHistory.forEach(e => counts[e] = (counts[e] || 0) + 1);
      
      let maxCount = 0;
      let dominant = currentEmotion;
      for (const [emotion, count] of Object.entries(counts)) {
        if (count > maxCount) {
          maxCount = count;
          dominant = emotion;
        }
      }
      return dominant;
    }
    
    function updateConnectionStatus(message, status) {
      const el = document.getElementById('connectionStatus');
      el.textContent = message;
      el.className = `connection-status ${status}`;
    }
    
    function formatTime(seconds) {
      const h = Math.floor(seconds / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      const s = Math.floor(seconds % 60);
      return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }
    
    function updateTimer() {
      if (!sessionStartTime || isPaused) return;
      const elapsed = Math.floor((Date.now() - sessionStartTime) / 1000) - pausedTime;
      document.getElementById('timerDisplay').textContent = formatTime(elapsed);
    }
    
    function togglePause() {
      isPaused = !isPaused;
      const btn = document.getElementById('pauseBtn');
      btn.textContent = isPaused ? 'Resume' : 'Pause';
      
      if (isPaused) {
        pausedTime = Math.floor((Date.now() - sessionStartTime) / 1000);
      }
    }
    
    function takeBreak() {
      breaksTaken++;
      document.getElementById('breaksTaken').textContent = breaksTaken;
      document.getElementById('breakReminder').classList.remove('active');
      
      fetch('/api/focus/session', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ student_id: studentId, action: 'break' })
      });
    }
    
    function dismissBreak() {
      document.getElementById('breakReminder').classList.remove('active');
    }
    
    function endSession() {
      if (confirm('Are you sure you want to end this focus session?')) {
        isSessionActive = false;
        if (camera) camera.stop();
        
        fetch('/api/student/leave', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ student_id: studentId })
        });
        
        document.getElementById('dashboard').classList.remove('active');
        document.getElementById('joinSection').style.display = 'block';
      }
    }
    
    async function sendReport() {
      if (!isSessionActive || batchAccumulator.count === 0 || isPaused) return;
      
      const count = batchAccumulator.count;
      const avgAttention = Math.round(batchAccumulator.attentionSum / count);
      const faceRatio = batchAccumulator.facePresentCount / count;
      const gazeRatio = batchAccumulator.gazeOnScreenCount / count;
      
      let dominantEmotion = 'neutral';
      let maxEmoCount = 0;
      for (const [emo, c] of Object.entries(batchAccumulator.emotions)) {
        if (c > maxEmoCount) {
          maxEmoCount = c;
          dominantEmotion = emo;
        }
      }
      
      const engagementLevel = avgAttention >= 70 ? 'high' : avgAttention >= 40 ? 'medium' : 'low';
      
      const payload = {
        student_id: studentId,
        name: studentName,
        guid: studentGuid,
        face_present_ratio: parseFloat(faceRatio.toFixed(2)),
        gaze_on_screen_ratio: parseFloat(gazeRatio.toFixed(2)),
        blink_rate: 0,
        attention_score: avgAttention,
        emotion: dominantEmotion,
        engagement_level: engagementLevel
      };
      
      try {
        updateConnectionStatus('Sending Report...', 'connected');
        const response = await fetch('/api/student/update', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        
        const result = await response.json();
        
        if (result.break_suggestion) {
          document.getElementById('breakReminderText').textContent = result.break_suggestion.message;
          document.getElementById('breakReminder').classList.add('active');
        }
        
        updateConnectionStatus('Connected - Monitoring Active', 'connected');
        
        attentionData.push({ time: new Date().toLocaleTimeString(), value: avgAttention });
        if (attentionData.length > 20) attentionData.shift();
        updateAttentionChart();
        
        moodHistoryData.unshift({
          emotion: dominantEmotion,
          attention: avgAttention,
          time: new Date().toLocaleTimeString()
        });
        if (moodHistoryData.length > 10) moodHistoryData.pop();
        updateMoodHistory();
        
        updateInsights(avgAttention, dominantEmotion);
        
        const totalAttention = attentionData.reduce((sum, d) => sum + d.value, 0);
        document.getElementById('avgAttention').textContent = Math.round(totalAttention / attentionData.length) + '%';
        
        resetAccumulator();
      } catch (e) {
        console.error("Report failed:", e);
        updateConnectionStatus('Report Failed - Retrying...', 'error');
      }
    }
    
    function resetAccumulator() {
      batchAccumulator = {
        count: 0, attentionSum: 0, facePresentCount: 0,
        gazeOnScreenCount: 0, eyesClosedCount: 0, emotions: {}
      };
    }
    
    function initAttentionChart() {
      const ctx = document.getElementById('attentionChart').getContext('2d');
      attentionChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: 'Attention',
            data: [],
            borderColor: '#667eea',
            backgroundColor: 'rgba(102, 126, 234, 0.1)',
            fill: true,
            tension: 0.4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              max: 100,
              ticks: { color: '#94a3b8' },
              grid: { color: '#334155' }
            },
            x: {
              ticks: { color: '#94a3b8', maxTicksLimit: 6 },
              grid: { color: '#334155' }
            }
          },
          plugins: {
            legend: { display: false }
          }
        }
      });
    }
    
    function updateAttentionChart() {
      if (!attentionChart) return;
      attentionChart.data.labels = attentionData.map(d => d.time);
      attentionChart.data.datasets[0].data = attentionData.map(d => d.value);
      attentionChart.update('none');
    }
    
    function updateMoodHistory() {
      const container = document.getElementById('moodHistory');
      container.innerHTML = moodHistoryData.map(entry => `
        <div class="mood-entry">
          <span class="mood-emoji">${emotionEmojis[entry.emotion] || '&#128528;'}</span>
          <div class="mood-details">
            <div class="mood-attention">${entry.attention}% attention</div>
            <div class="mood-time">${entry.time}</div>
          </div>
        </div>
      `).join('');
      
      if (attentionData.length >= 4) {
        const recent = attentionData.slice(-4);
        const firstHalf = (recent[0].value + recent[1].value) / 2;
        const secondHalf = (recent[2].value + recent[3].value) / 2;
        
        const indicator = document.getElementById('trendIndicator');
        if (secondHalf > firstHalf + 5) {
          indicator.textContent = 'Improving';
          indicator.className = 'trend-indicator improving';
        } else if (secondHalf < firstHalf - 5) {
          indicator.textContent = 'Declining';
          indicator.className = 'trend-indicator declining';
        } else {
          indicator.textContent = 'Stable';
          indicator.className = 'trend-indicator stable';
        }
      }
    }
    
    function updateInsights(attention, emotion) {
      const insights = [];
      
      if (attention >= 70) {
        insights.push({ icon: '&#127775;', text: 'Great focus! Keep up the excellent work.' });
      } else if (attention >= 40) {
        insights.push({ icon: '&#128161;', text: 'Good attention. Try to minimize distractions.' });
      } else {
        insights.push({ icon: '&#9888;', text: 'Low attention detected. Consider taking a short break.' });
      }
      
      if (emotion === 'happy') {
        insights.push({ icon: '&#128522;', text: 'Positive mood detected - great for learning!' });
      } else if (emotion === 'sad' || emotion === 'fearful') {
        insights.push({ icon: '&#128170;', text: 'Take a moment to breathe and refocus.' });
      }
      
      const elapsed = sessionStartTime ? Math.floor((Date.now() - sessionStartTime) / 1000 / 60) : 0;
      if (elapsed >= 45) {
        insights.push({ icon: '&#9749;', text: `You've been focusing for ${elapsed} minutes. Consider a break!` });
      }
      
      document.getElementById('insightsContainer').innerHTML = insights.map(i => `
        <div class="insight-item">
          <span class="insight-icon">${i.icon}</span>
          <span class="insight-text">${i.text}</span>
        </div>
      `).join('');
    }
    
    async function startPollingLoop() {
      try {
        const response = await fetch('/api/student/join', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ student_id: studentId, name: studentName })
        });
        
        if (response.ok) {
          const result = await response.json();
          studentGuid = result.guid;
          console.log('Joined successfully with GUID:', studentGuid);
          updateConnectionStatus('Connected - Accumulating Data...', 'connected');
        } else {
          updateConnectionStatus('Connection Failed', 'error');
        }
      } catch (e) {
        console.error("Join failed:", e);
        updateConnectionStatus('Connection Warning', 'error');
      }
      
      setTimeout(sendReport, 10000);
      setInterval(sendReport, POLL_INTERVAL);
    }
    
    async function joinSession() {
      const idInput = document.getElementById('studentIdInput').value.trim();
      const nameInput = document.getElementById('studentNameInput').value.trim();
      
      if (!idInput) {
        alert('Please enter your student ID');
        return;
      }
      
      studentId = idInput;
      studentName = nameInput || `Student ${idInput}`;
      
      document.getElementById('studentIdDisplay').textContent = studentId;
      document.getElementById('studentNameDisplay').textContent = studentName;
      
      document.getElementById('joinSection').style.display = 'none';
      document.getElementById('dashboard').classList.add('active');
      
      sessionStartTime = Date.now();
      setInterval(updateTimer, 1000);
      
      initAttentionChart();
      
      updateConnectionStatus('Loading models...', '');
      await loadFaceApiModels();
      
      isSessionActive = true;
      startPollingLoop();
      await startMediaPipe();
    }
    
    async function startMediaPipe() {
      try {
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let attempts = 0;
        while ((!window.Camera || !window.FaceMesh) && attempts < 50) {
          await new Promise(resolve => setTimeout(resolve, 100));
          attempts++;
        }
        
        if (!window.FaceMesh) throw new Error('FaceMesh failed to load');
        
        faceMesh = new window.FaceMesh({
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
        });
        
        faceMesh.setOptions({
          maxNumFaces: 1,
          refineLandmarks: true,
          minDetectionConfidence: 0.5,
          minTrackingConfidence: 0.5
        });
        
        faceMesh.onResults((results) => onResults(results, canvas, ctx));
        
        camera = new window.Camera(video, {
          onFrame: async () => await faceMesh.send({ image: video }),
          width: 640,
          height: 480
        });
        
        await camera.start();
        updateConnectionStatus('Monitoring Active - Next Report in 30sec', 'connected');
        
      } catch (error) {
        console.error('Error:', error);
        updateConnectionStatus('Error: Could not start camera', 'error');
      }
    }
    
    function onResults(results, canvas, ctx) {
      if (!results || !results.image || isPaused) return;
      
      if (canvas.width !== results.image.width) {
        canvas.width = results.image.width;
        canvas.height = results.image.height;
      }
      
      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      let currentAttention = 0;
      let currentLimitEmotion = 'neutral';
      
      if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
        const landmarks = results.multiFaceLandmarks[0];
        
        if (window.drawConnectors && window.FACEMESH_FACE_OVAL) {
          window.drawConnectors(ctx, landmarks, window.FACEMESH_FACE_OVAL, { color: '#FFFFFF40', lineWidth: 1 });
        }
        
        drawLandmarkLine(ctx, landmarks, LEFT_EYE_IDX, '#667eea', 2, true);
        drawLandmarkLine(ctx, landmarks, RIGHT_EYE_IDX, '#667eea', 2, true);
        drawLandmarkPoints(ctx, landmarks, LEFT_EYE_IDX, '#764ba2', 2);
        drawLandmarkPoints(ctx, landmarks, RIGHT_EYE_IDX, '#764ba2', 2);
        
        drawLandmarkLine(ctx, landmarks, LEFT_EYEBROW_IDX, '#22c55e', 2, false);
        drawLandmarkLine(ctx, landmarks, RIGHT_EYEBROW_IDX, '#22c55e', 2, false);
        
        drawLandmarkLine(ctx, landmarks, MOUTH_OUTER_IDX, '#06b6d4', 2, true);
        drawLandmarkLine(ctx, landmarks, MOUTH_INNER_IDX, '#0ea5e9', 1, true);
        
        drawPoint(ctx, landmarks[RIGHT_IRIS_CENTER], '#f59e0b', 6);
        drawPoint(ctx, landmarks[LEFT_IRIS_CENTER], '#f59e0b', 6);
        
        const headPose = estimateHeadInFocus(landmarks);
        const gaze = estimateGazeDirection(landmarks);
        
        const now = Date.now();
        if (faceApiReady && (now - lastEmotionDetectTime) >= EMOTION_DETECT_INTERVAL) {
          lastEmotionDetectTime = now;
          detectEmotionWithFaceApi(document.getElementById('webcam')).then(detected => {
            if (detected) currentEmotion = getSmoothedEmotion(detected);
          });
        }
        currentLimitEmotion = currentEmotion;
        
        const leftEAR = eyeAspectRatio(landmarks, LEFT_EYE_IDX, canvas.width, canvas.height);
        const rightEAR = eyeAspectRatio(landmarks, RIGHT_EYE_IDX, canvas.width, canvas.height);
        const avgEAR = (leftEAR + rightEAR) / 2.0;
        const eyesClosed = avgEAR < 0.21;
        
        if (eyesClosed) {
          eyesClosedCount++;
        } else {
          eyesClosedCount = Math.max(0, eyesClosedCount - 1);
        }
        
        const prolongedEyesClosed = eyesClosedCount > 10;
        
        let targetScore = 0;
        if (headPose.inFocus) targetScore += 0.35;
        if (gaze.lookingCenter) targetScore += 0.35;
        if (!eyesClosed) targetScore += 0.15;
        if (currentEmotion === 'happy' || currentEmotion === 'neutral') targetScore += 0.15;
        
        if (prolongedEyesClosed) {
          targetScore = Math.min(targetScore, 0.25);
        }
        
        const rate = targetScore > previousAttentionScore ? 0.12 : 0.08;
        const attentionScore = previousAttentionScore + (targetScore - previousAttentionScore) * rate;
        previousAttentionScore = attentionScore;
        currentAttention = Math.round(attentionScore * 100);
        
        batchAccumulator.count++;
        batchAccumulator.attentionSum += currentAttention;
        batchAccumulator.facePresentCount++;
        if (gaze.lookingCenter) batchAccumulator.gazeOnScreenCount++;
        if (eyesClosed) batchAccumulator.eyesClosedCount++;
        batchAccumulator.emotions[currentLimitEmotion] = (batchAccumulator.emotions[currentLimitEmotion] || 0) + 1;
        
        const headStatus = headPose.inFocus ? 'OK' : 'Away';
        const gazeStatus = gaze.lookingCenter ? 'OK' : 'Away';
        const eyesStatus = prolongedEyesClosed ? ' | EYES CLOSED' : '';
        document.getElementById('debugInfo').innerHTML = 
          `Head: ${headStatus} | Gaze: ${gazeStatus} | Emotion: ${currentEmotion} | EAR: ${avgEAR.toFixed(2)}${eyesStatus}`;
        
      } else {
        previousAttentionScore *= 0.95;
        currentAttention = Math.round(previousAttentionScore * 100);
        
        batchAccumulator.count++;
        batchAccumulator.attentionSum += currentAttention;
        batchAccumulator.emotions['neutral'] = (batchAccumulator.emotions['neutral'] || 0) + 1;
        
        document.getElementById('debugInfo').innerHTML = 'No face detected - attention decreasing';
      }
      
      ctx.restore();
      
      const engagementLevel = currentAttention >= 70 ? 'high' : currentAttention >= 40 ? 'medium' : 'low';
      updateMetrics({
        attention_score: currentAttention,
        engagement_level: engagementLevel,
        emotion: currentLimitEmotion
      });
    }
    
    function updateMetrics(data) {
      const scoreEl = document.getElementById('attentionScore');
      scoreEl.textContent = data.attention_score + '%';
      scoreEl.className = 'metric-value ' + (data.attention_score >= 70 ? 'high' : data.attention_score >= 40 ? 'medium' : 'low');
      
      const levelEl = document.getElementById('engagementLevel');
      levelEl.textContent = data.engagement_level.toUpperCase();
      levelEl.className = `metric-value ${data.engagement_level}`;
      
      document.getElementById('emotionDisplay').innerHTML = emotionEmojis[data.emotion] || '&#128528;';
      document.getElementById('emotionName').textContent = data.emotion;
    }
    
    window.addEventListener('beforeunload', async () => {
      if (camera) camera.stop();
      isSessionActive = false;
      await sendReport();
      
      try {
        await fetch('/api/student/leave', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ student_id: studentId, name: studentName }),
          keepalive: true
        });
      } catch (e) {
        console.error('Leave notification failed:', e);
      }
    });
  </script>
</body>
</html>
